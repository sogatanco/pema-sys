{"version":3,"file":"static/js/6329.bb1bb194.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/notifyManager.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/utils.ts","../node_modules/@tanstack/react-query/src/isRestoring.tsx","../node_modules/@tanstack/react-query/src/suspense.ts","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts"],"sourcesContent":["import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nexport { _objectWithoutProperties as default };","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.focused !== focused\n    if (changed) {\n      this.focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends unknown[]> = (...args: T) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends unknown[]>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nconst onlineEvents = ['online', 'offline'] as const\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        onlineEvents.forEach((event) => {\n          window.addEventListener(event, listener, false)\n        })\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach((event) => {\n            window.removeEventListener(event, listener)\n          })\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    const changed = this.online !== online\n\n    if (changed) {\n      this.online = online\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Action, FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result\n      this.currentResultOptions = this.options\n      this.currentResultState = this.currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.trackedProps,\n      )\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false\n  }\n\n  // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData\n  }\n\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<{ listener: TListener }>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    const identity = { listener }\n    this.listeners.add(identity)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(identity)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n"],"names":["_objectWithoutProperties","e","t","o","r","i","Object","getOwnPropertySymbols","s","length","includes","propertyIsEnumerable","call","FocusManager","Subscribable","constructor","super","this","setup","onFocus","isServer","window","addEventListener","listener","removeEventListener","onSubscribe","cleanup","setEventListener","onUnsubscribe","_this$cleanup","hasListeners","undefined","_this$cleanup2","focused","setFocused","listeners","forEach","_ref","isFocused","document","visibilityState","focusManager","notifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","schedule","push","scheduleMicrotask","flush","originalQueue","batch","result","batchCalls","_len","arguments","args","Array","_key","setNotifyFunction","fn","setBatchNotifyFunction","createNotifyManager","onlineEvents","OnlineManager","onOnline","event","online","setOnline","isOnline","navigator","onLine","onlineManager","QueryObserver","client","options","trackedProps","Set","selectError","bindMethods","setOptions","remove","bind","refetch","size","currentQuery","addObserver","shouldFetchOnMount","executeFetch","updateTimers","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","shallowEqualObjects","getQueryCache","notify","type","query","observer","enabled","Error","queryKey","updateQuery","mounted","shouldFetchOptionally","updateResult","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","build","createResult","optimisticResult","keepPreviousData","placeholderData","isPlaceholderData","getCurrentResult","shouldAssignObserverCurrentProperties","currentResult","currentResultOptions","currentResultState","state","trackResult","trackedResult","keys","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","refetchPage","_excluded","fetch","_objectSpread","meta","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","_fetchOptions$cancelR","cancelRefetch","promise","throwOnError","catch","noop","isStale","isValidTimeout","timeout","timeUntilStale","dataUpdatedAt","staleTimeoutId","setTimeout","_this$options$refetch","refetchInterval","data","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","error","errorUpdatedAt","fetchStatus","status","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","canFetch","networkMode","isSuccess","select","selectFn","selectResult","replaceData","process","Date","now","isFetching","isLoading","isError","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","cache","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","useErrorBoundary","some","typedKey","has","onQueryUpdate","action","onSuccess","manual","isCancelledError","onError","_this$options$onSucce","_this$options","_this$options$onSettl","_this$options2","onSettled","_this$options$onError","_this$options3","_this$options$onSettl2","_this$options4","_ref2","retryOnMount","shouldLoadOnMount","refetchOnMount","field","value","suspense","isStaleByTime","defaultRetryDelay","Math","min","CancelledError","revert","silent","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","Promise","outerResolve","outerReject","shouldPause","resolve","reject","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","sleep","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","subscribe","identity","delete","functionalUpdate","updater","input","Infinity","difference","array1","array2","filter","x","replaceAt","array","index","copy","slice","updatedAt","max","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryFn","parseFilterArgs","matchQuery","filters","exact","predicate","stale","queryHash","hashQueryKeyByOptions","partialMatchKey","isActive","matchMutation","mutation","fetching","mutationKey","hashQueryKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","sort","reduce","a","b","partialDeepEqual","replaceEqualDeep","isPlainArray","aSize","bItems","bSize","equalItems","isArray","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","getAbortController","AbortController","prevData","isDataEqual","structuralSharing","defaultContext","React","QueryClientSharingContext","getQueryClientContext","context","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","QueryClientProvider","mount","unmount","Context","createValue","clearReset","isReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","errorResetBoundary","useClearResetErrorBoundary","getHasError","_useErrorBoundary","params","IsRestoringContext","useIsRestoring","Provider","ensureStaleTime","willFetch","isRestoring","shouldSuspend","useSyncExternalStore","useSyncExternalStore$1"],"sourceRoot":""}