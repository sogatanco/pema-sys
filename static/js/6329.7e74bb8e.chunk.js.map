{"version":3,"file":"static/js/6329.7e74bb8e.chunk.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/notifyManager.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/utils.ts","../node_modules/@tanstack/react-query/src/isRestoring.tsx","../node_modules/@tanstack/react-query/src/suspense.ts","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.focused !== focused\n    if (changed) {\n      this.focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends unknown[]> = (...args: T) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends unknown[]>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nconst onlineEvents = ['online', 'offline'] as const\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        onlineEvents.forEach((event) => {\n          window.addEventListener(event, listener, false)\n        })\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach((event) => {\n            window.removeEventListener(event, listener)\n          })\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    const changed = this.online !== online\n\n    if (changed) {\n      this.online = online\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Action, FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result\n      this.currentResultOptions = this.options\n      this.currentResultState = this.currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.trackedProps,\n      )\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false\n  }\n\n  // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData\n  }\n\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<{ listener: TListener }>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    const identity = { listener }\n    this.listeners.add(identity)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(identity)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n"],"names":["FocusManager","Subscribable","constructor","super","this","setup","onFocus","isServer","window","addEventListener","listener","removeEventListener","onSubscribe","cleanup","setEventListener","onUnsubscribe","_this$cleanup","hasListeners","call","undefined","_this$cleanup2","focused","setFocused","listeners","forEach","_ref","isFocused","document","includes","visibilityState","focusManager","notifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","schedule","push","scheduleMicrotask","flush","originalQueue","length","batch","result","batchCalls","_len","arguments","args","Array","_key","setNotifyFunction","fn","setBatchNotifyFunction","createNotifyManager","onlineEvents","OnlineManager","onOnline","event","online","setOnline","isOnline","navigator","onLine","onlineManager","QueryObserver","client","options","trackedProps","Set","selectError","bindMethods","setOptions","remove","bind","refetch","size","currentQuery","addObserver","shouldFetchOnMount","executeFetch","updateTimers","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","shallowEqualObjects","getQueryCache","notify","type","query","observer","enabled","Error","queryKey","updateQuery","mounted","shouldFetchOptionally","updateResult","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","build","createResult","optimisticResult","keepPreviousData","placeholderData","isPlaceholderData","getCurrentResult","shouldAssignObserverCurrentProperties","currentResult","currentResultOptions","currentResultState","state","trackResult","trackedResult","Object","keys","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","refetchPage","_objectWithoutProperties","_excluded","fetch","_objectSpread","meta","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","_fetchOptions$cancelR","cancelRefetch","promise","throwOnError","catch","noop","isStale","isValidTimeout","timeout","timeUntilStale","dataUpdatedAt","staleTimeoutId","setTimeout","_this$options$refetch","refetchInterval","data","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","error","errorUpdatedAt","fetchStatus","status","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","canFetch","networkMode","isSuccess","select","selectFn","selectResult","replaceData","process","Date","now","isFetching","isLoading","isError","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","cache","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","useErrorBoundary","some","typedKey","has","onQueryUpdate","action","onSuccess","manual","isCancelledError","onError","_this$options$onSucce","_this$options","_this$options$onSettl","_this$options2","onSettled","_this$options$onError","_this$options3","_this$options$onSettl2","_this$options4","_ref2","retryOnMount","shouldLoadOnMount","refetchOnMount","field","value","suspense","isStaleByTime","defaultRetryDelay","Math","min","CancelledError","revert","silent","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","Promise","outerResolve","outerReject","shouldPause","resolve","reject","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","sleep","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","subscribe","identity","delete","functionalUpdate","updater","input","Infinity","difference","array1","array2","filter","x","replaceAt","array","index","copy","slice","updatedAt","max","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryFn","parseFilterArgs","matchQuery","filters","exact","predicate","stale","queryHash","hashQueryKeyByOptions","partialMatchKey","isActive","matchMutation","mutation","fetching","mutationKey","hashQueryKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","sort","reduce","a","b","partialDeepEqual","replaceEqualDeep","isPlainArray","aSize","bItems","bSize","equalItems","i","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","getAbortController","AbortController","prevData","isDataEqual","structuralSharing","defaultContext","React","QueryClientSharingContext","getQueryClientContext","context","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","QueryClientProvider","mount","unmount","Context","createValue","clearReset","isReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","errorResetBoundary","useClearResetErrorBoundary","getHasError","_useErrorBoundary","params","IsRestoringContext","useIsRestoring","Provider","ensureStaleTime","willFetch","isRestoring","shouldSuspend","useSyncExternalStore","useSyncExternalStore$1"],"sourceRoot":""}