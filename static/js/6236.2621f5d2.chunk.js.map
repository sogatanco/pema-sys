{"version":3,"file":"static/js/6236.2621f5d2.chunk.js","mappings":"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","sources":["../node_modules/html-to-image/src/util.ts","../node_modules/html-to-image/src/clone-pseudos.ts","../node_modules/html-to-image/src/mimes.ts","../node_modules/html-to-image/src/dataurl.ts","../node_modules/html-to-image/src/clone-node.ts","../node_modules/html-to-image/src/embed-resources.ts","../node_modules/html-to-image/src/embed-images.ts","../node_modules/html-to-image/src/embed-webfonts.ts","../node_modules/html-to-image/src/index.ts","../node_modules/html-to-image/src/apply-style.ts","pages/qrcode/QrCodeGenerator.js"],"sourcesContent":["import type { Options } from './types'\n\nexport function resolveUrl(url: string, baseUrl: string | null): string {\n  // url is absolute already\n  if (url.match(/^[a-z]+:\\/\\//i)) {\n    return url\n  }\n\n  // url is absolute already, without protocol\n  if (url.match(/^\\/\\//)) {\n    return window.location.protocol + url\n  }\n\n  // dataURI, mailto:, tel:, etc.\n  if (url.match(/^[a-z]+:/i)) {\n    return url\n  }\n\n  const doc = document.implementation.createHTMLDocument()\n  const base = doc.createElement('base')\n  const a = doc.createElement('a')\n\n  doc.head.appendChild(base)\n  doc.body.appendChild(a)\n\n  if (baseUrl) {\n    base.href = baseUrl\n  }\n\n  a.href = url\n\n  return a.href\n}\n\nexport const uuid = (() => {\n  // generate uuid for className of pseudo elements.\n  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n  let counter = 0\n\n  // ref: http://stackoverflow.com/a/6248722/2519373\n  const random = () =>\n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)\n\n  return () => {\n    counter += 1\n    return `u${random()}${counter}`\n  }\n})()\n\nexport function delay<T>(ms: number) {\n  return (args: T) =>\n    new Promise<T>((resolve) => {\n      setTimeout(() => resolve(args), ms)\n    })\n}\n\nexport function toArray<T>(arrayLike: any): T[] {\n  const arr: T[] = []\n\n  for (let i = 0, l = arrayLike.length; i < l; i++) {\n    arr.push(arrayLike[i])\n  }\n\n  return arr\n}\n\nfunction px(node: HTMLElement, styleProperty: string) {\n  const win = node.ownerDocument.defaultView || window\n  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)\n  return val ? parseFloat(val.replace('px', '')) : 0\n}\n\nfunction getNodeWidth(node: HTMLElement) {\n  const leftBorder = px(node, 'border-left-width')\n  const rightBorder = px(node, 'border-right-width')\n  return node.clientWidth + leftBorder + rightBorder\n}\n\nfunction getNodeHeight(node: HTMLElement) {\n  const topBorder = px(node, 'border-top-width')\n  const bottomBorder = px(node, 'border-bottom-width')\n  return node.clientHeight + topBorder + bottomBorder\n}\n\nexport function getImageSize(targetNode: HTMLElement, options: Options = {}) {\n  const width = options.width || getNodeWidth(targetNode)\n  const height = options.height || getNodeHeight(targetNode)\n\n  return { width, height }\n}\n\nexport function getPixelRatio() {\n  let ratio\n\n  let FINAL_PROCESS\n  try {\n    FINAL_PROCESS = process\n  } catch (e) {\n    // pass\n  }\n\n  const val =\n    FINAL_PROCESS && FINAL_PROCESS.env\n      ? FINAL_PROCESS.env.devicePixelRatio\n      : null\n  if (val) {\n    ratio = parseInt(val, 10)\n    if (Number.isNaN(ratio)) {\n      ratio = 1\n    }\n  }\n  return ratio || window.devicePixelRatio || 1\n}\n\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384\n\nexport function checkCanvasDimensions(canvas: HTMLCanvasElement) {\n  if (\n    canvas.width > canvasDimensionLimit ||\n    canvas.height > canvasDimensionLimit\n  ) {\n    if (\n      canvas.width > canvasDimensionLimit &&\n      canvas.height > canvasDimensionLimit\n    ) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= canvasDimensionLimit / canvas.width\n        canvas.width = canvasDimensionLimit\n      } else {\n        canvas.width *= canvasDimensionLimit / canvas.height\n        canvas.height = canvasDimensionLimit\n      }\n    } else if (canvas.width > canvasDimensionLimit) {\n      canvas.height *= canvasDimensionLimit / canvas.width\n      canvas.width = canvasDimensionLimit\n    } else {\n      canvas.width *= canvasDimensionLimit / canvas.height\n      canvas.height = canvasDimensionLimit\n    }\n  }\n}\n\nexport function canvasToBlob(\n  canvas: HTMLCanvasElement,\n  options: Options = {},\n): Promise<Blob | null> {\n  if (canvas.toBlob) {\n    return new Promise((resolve) => {\n      canvas.toBlob(\n        resolve,\n        options.type ? options.type : 'image/png',\n        options.quality ? options.quality : 1,\n      )\n    })\n  }\n\n  return new Promise((resolve) => {\n    const binaryString = window.atob(\n      canvas\n        .toDataURL(\n          options.type ? options.type : undefined,\n          options.quality ? options.quality : undefined,\n        )\n        .split(',')[1],\n    )\n    const len = binaryString.length\n    const binaryArray = new Uint8Array(len)\n\n    for (let i = 0; i < len; i += 1) {\n      binaryArray[i] = binaryString.charCodeAt(i)\n    }\n\n    resolve(\n      new Blob([binaryArray], {\n        type: options.type ? options.type : 'image/png',\n      }),\n    )\n  })\n}\n\nexport function createImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.decode = () => resolve(img) as any\n    img.onload = () => resolve(img)\n    img.onerror = reject\n    img.crossOrigin = 'anonymous'\n    img.decoding = 'async'\n    img.src = url\n  })\n}\n\nexport async function svgToDataURL(svg: SVGElement): Promise<string> {\n  return Promise.resolve()\n    .then(() => new XMLSerializer().serializeToString(svg))\n    .then(encodeURIComponent)\n    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)\n}\n\nexport async function nodeToDataURL(\n  node: HTMLElement,\n  width: number,\n  height: number,\n): Promise<string> {\n  const xmlns = 'http://www.w3.org/2000/svg'\n  const svg = document.createElementNS(xmlns, 'svg')\n  const foreignObject = document.createElementNS(xmlns, 'foreignObject')\n\n  svg.setAttribute('width', `${width}`)\n  svg.setAttribute('height', `${height}`)\n  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)\n\n  foreignObject.setAttribute('width', '100%')\n  foreignObject.setAttribute('height', '100%')\n  foreignObject.setAttribute('x', '0')\n  foreignObject.setAttribute('y', '0')\n  foreignObject.setAttribute('externalResourcesRequired', 'true')\n\n  svg.appendChild(foreignObject)\n  foreignObject.appendChild(node)\n  return svgToDataURL(svg)\n}\n\nexport const isInstanceOfElement = <\n  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,\n>(\n  node: Element | HTMLElement | SVGImageElement,\n  instance: T,\n): node is T['prototype'] => {\n  if (node instanceof instance) return true\n\n  const nodePrototype = Object.getPrototypeOf(node)\n\n  if (nodePrototype === null) return false\n\n  return (\n    nodePrototype.constructor.name === instance.name ||\n    isInstanceOfElement(nodePrototype, instance)\n  )\n}\n","import { uuid, toArray } from './util'\n\ntype Pseudo = ':before' | ':after'\n\nfunction formatCSSText(style: CSSStyleDeclaration) {\n  const content = style.getPropertyValue('content')\n  return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`\n}\n\nfunction formatCSSProperties(style: CSSStyleDeclaration) {\n  return toArray<string>(style)\n    .map((name) => {\n      const value = style.getPropertyValue(name)\n      const priority = style.getPropertyPriority(name)\n\n      return `${name}: ${value}${priority ? ' !important' : ''};`\n    })\n    .join(' ')\n}\n\nfunction getPseudoElementStyle(\n  className: string,\n  pseudo: Pseudo,\n  style: CSSStyleDeclaration,\n): Text {\n  const selector = `.${className}:${pseudo}`\n  const cssText = style.cssText\n    ? formatCSSText(style)\n    : formatCSSProperties(style)\n\n  return document.createTextNode(`${selector}{${cssText}}`)\n}\n\nfunction clonePseudoElement<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  pseudo: Pseudo,\n) {\n  const style = window.getComputedStyle(nativeNode, pseudo)\n  const content = style.getPropertyValue('content')\n  if (content === '' || content === 'none') {\n    return\n  }\n\n  const className = uuid()\n  try {\n    clonedNode.className = `${clonedNode.className} ${className}`\n  } catch (err) {\n    return\n  }\n\n  const styleElement = document.createElement('style')\n  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style))\n  clonedNode.appendChild(styleElement)\n}\n\nexport function clonePseudoElements<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n) {\n  clonePseudoElement(nativeNode, clonedNode, ':before')\n  clonePseudoElement(nativeNode, clonedNode, ':after')\n}\n","const WOFF = 'application/font-woff'\nconst JPEG = 'image/jpeg'\nconst mimes: { [key: string]: string } = {\n  woff: WOFF,\n  woff2: WOFF,\n  ttf: 'application/font-truetype',\n  eot: 'application/vnd.ms-fontobject',\n  png: 'image/png',\n  jpg: JPEG,\n  jpeg: JPEG,\n  gif: 'image/gif',\n  tiff: 'image/tiff',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n}\n\nfunction getExtension(url: string): string {\n  const match = /\\.([^./]*?)$/g.exec(url)\n  return match ? match[1] : ''\n}\n\nexport function getMimeType(url: string): string {\n  const extension = getExtension(url).toLowerCase()\n  return mimes[extension] || ''\n}\n","import { Options } from './types'\n\nfunction getContentFromDataUrl(dataURL: string) {\n  return dataURL.split(/,/)[1]\n}\n\nexport function isDataUrl(url: string) {\n  return url.search(/^(data:)/) !== -1\n}\n\nexport function makeDataUrl(content: string, mimeType: string) {\n  return `data:${mimeType};base64,${content}`\n}\n\nexport async function fetchAsDataURL<T>(\n  url: string,\n  init: RequestInit | undefined,\n  process: (data: { result: string; res: Response }) => T,\n): Promise<T> {\n  const res = await fetch(url, init)\n  if (res.status === 404) {\n    throw new Error(`Resource \"${res.url}\" not found`)\n  }\n  const blob = await res.blob()\n  return new Promise<T>((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onerror = reject\n    reader.onloadend = () => {\n      try {\n        resolve(process({ res, result: reader.result as string }))\n      } catch (error) {\n        reject(error)\n      }\n    }\n\n    reader.readAsDataURL(blob)\n  })\n}\n\nconst cache: { [url: string]: string } = {}\n\nfunction getCacheKey(\n  url: string,\n  contentType: string | undefined,\n  includeQueryParams: boolean | undefined,\n) {\n  let key = url.replace(/\\?.*/, '')\n\n  if (includeQueryParams) {\n    key = url\n  }\n\n  // font resource\n  if (/ttf|otf|eot|woff2?/i.test(key)) {\n    key = key.replace(/.*\\//, '')\n  }\n\n  return contentType ? `[${contentType}]${key}` : key\n}\n\nexport async function resourceToDataURL(\n  resourceUrl: string,\n  contentType: string | undefined,\n  options: Options,\n) {\n  const cacheKey = getCacheKey(\n    resourceUrl,\n    contentType,\n    options.includeQueryParams,\n  )\n\n  if (cache[cacheKey] != null) {\n    return cache[cacheKey]\n  }\n\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n  if (options.cacheBust) {\n    // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()\n  }\n\n  let dataURL: string\n  try {\n    const content = await fetchAsDataURL(\n      resourceUrl,\n      options.fetchRequestInit,\n      ({ res, result }) => {\n        if (!contentType) {\n          // eslint-disable-next-line no-param-reassign\n          contentType = res.headers.get('Content-Type') || ''\n        }\n        return getContentFromDataUrl(result)\n      },\n    )\n    dataURL = makeDataUrl(content, contentType!)\n  } catch (error) {\n    dataURL = options.imagePlaceholder || ''\n\n    let msg = `Failed to fetch resource: ${resourceUrl}`\n    if (error) {\n      msg = typeof error === 'string' ? error : error.message\n    }\n\n    if (msg) {\n      console.warn(msg)\n    }\n  }\n\n  cache[cacheKey] = dataURL\n  return dataURL\n}\n","import type { Options } from './types'\nimport { clonePseudoElements } from './clone-pseudos'\nimport { createImage, toArray, isInstanceOfElement } from './util'\nimport { getMimeType } from './mimes'\nimport { resourceToDataURL } from './dataurl'\n\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\n  const dataURL = canvas.toDataURL()\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false) as HTMLCanvasElement\n  }\n  return createImage(dataURL)\n}\n\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    canvas.width = video.clientWidth\n    canvas.height = video.clientHeight\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\n    const dataURL = canvas.toDataURL()\n    return createImage(dataURL)\n  }\n\n  const poster = video.poster\n  const contentType = getMimeType(poster)\n  const dataURL = await resourceToDataURL(poster, contentType, options)\n  return createImage(dataURL)\n}\n\nasync function cloneIFrameElement(iframe: HTMLIFrameElement) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return (await cloneNode(\n        iframe.contentDocument.body,\n        {},\n        true,\n      )) as HTMLBodyElement\n    }\n  } catch {\n    // Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false) as HTMLIFrameElement\n}\n\nasync function cloneSingleNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<HTMLElement> {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node)\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options)\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node)\n  }\n\n  return node.cloneNode(false) as T\n}\n\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\n\nasync function cloneChildren<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  options: Options,\n): Promise<T> {\n  let children: T[] = []\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray<T>(nativeNode.assignedNodes())\n  } else if (\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n    nativeNode.contentDocument?.body\n  ) {\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\n  } else {\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\n  }\n\n  if (\n    children.length === 0 ||\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\n  ) {\n    return clonedNode\n  }\n\n  await children.reduce(\n    (deferred, child) =>\n      deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild: HTMLElement | null) => {\n          if (clonedChild) {\n            clonedNode.appendChild(clonedChild)\n          }\n        }),\n    Promise.resolve(),\n  )\n\n  return clonedNode\n}\n\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  const targetStyle = clonedNode.style\n  if (!targetStyle) {\n    return\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode)\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\n  } else {\n    toArray<string>(sourceStyle).forEach((name) => {\n      let value = sourceStyle.getPropertyValue(name)\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont =\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\n        value = `${reducedFont}px`\n      }\n\n      if (\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        name === 'display' &&\n        value === 'inline'\n      ) {\n        value = 'block'\n      }\n      \n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`\n      }\n      \n      targetStyle.setProperty(\n        name,\n        value,\n        sourceStyle.getPropertyPriority(name),\n      )\n    })\n  }\n}\n\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value)\n  }\n}\n\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode as any as HTMLSelectElement\n    const selectedOption = Array.from(clonedSelect.children).find(\n      (child) => nativeNode.value === child.getAttribute('value'),\n    )\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '')\n    }\n  }\n}\n\nfunction decorate<T extends HTMLElement>(nativeNode: T, clonedNode: T): T {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode)\n    clonePseudoElements(nativeNode, clonedNode)\n    cloneInputValue(nativeNode, clonedNode)\n    cloneSelectValue(nativeNode, clonedNode)\n  }\n\n  return clonedNode\n}\n\nasync function ensureSVGSymbols<T extends HTMLElement>(\n  clone: T,\n  options: Options,\n) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\n  if (uses.length === 0) {\n    return clone\n  }\n\n  const processedDefs: { [key: string]: HTMLElement } = {}\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i]\n    const id = use.getAttribute('xlink:href')\n    if (id) {\n      const exist = clone.querySelector(id)\n      const definition = document.querySelector(id) as HTMLElement\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = (await cloneNode(definition, options, true))!\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs)\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml'\n    const svg = document.createElementNS(ns, 'svg')\n    svg.setAttribute('xmlns', ns)\n    svg.style.position = 'absolute'\n    svg.style.width = '0'\n    svg.style.height = '0'\n    svg.style.overflow = 'hidden'\n    svg.style.display = 'none'\n\n    const defs = document.createElementNS(ns, 'defs')\n    svg.appendChild(defs)\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i])\n    }\n\n    clone.appendChild(svg)\n  }\n\n  return clone\n}\n\nexport async function cloneNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n  isRoot?: boolean,\n): Promise<T | null> {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null\n  }\n\n  return Promise.resolve(node)\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\n    .then((clonedNode) => decorate(node, clonedNode))\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\n}\n","import { Options } from './types'\nimport { resolveUrl } from './util'\nimport { getMimeType } from './mimes'\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'\n\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g\n\nfunction toRegex(url: string): RegExp {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1')\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g')\n}\n\nexport function parseURLs(cssText: string): string[] {\n  const urls: string[] = []\n\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    urls.push(url)\n    return raw\n  })\n\n  return urls.filter((url) => !isDataUrl(url))\n}\n\nexport async function embed(\n  cssText: string,\n  resourceURL: string,\n  baseURL: string | null,\n  options: Options,\n  getContentFromUrl?: (url: string) => Promise<string>,\n): Promise<string> {\n  try {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL\n    const contentType = getMimeType(resourceURL)\n    let dataURL: string\n    if (getContentFromUrl) {\n      const content = await getContentFromUrl(resolvedURL)\n      dataURL = makeDataUrl(content, contentType)\n    } else {\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options)\n    }\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)\n  } catch (error) {\n    // pass\n  }\n  return cssText\n}\n\nfunction filterPreferredFontFormat(\n  str: string,\n  { preferredFontFormat }: Options,\n): string {\n  return !preferredFontFormat\n    ? str\n    : str.replace(FONT_SRC_REGEX, (match: string) => {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []\n          if (!format) {\n            return ''\n          }\n\n          if (format === preferredFontFormat) {\n            return `src: ${src};`\n          }\n        }\n      })\n}\n\nexport function shouldEmbed(url: string): boolean {\n  return url.search(URL_REGEX) !== -1\n}\n\nexport async function embedResources(\n  cssText: string,\n  baseUrl: string | null,\n  options: Options,\n): Promise<string> {\n  if (!shouldEmbed(cssText)) {\n    return cssText\n  }\n\n  const filteredCSSText = filterPreferredFontFormat(cssText, options)\n  const urls = parseURLs(filteredCSSText)\n  return urls.reduce(\n    (deferred, url) =>\n      deferred.then((css) => embed(css, url, baseUrl, options)),\n    Promise.resolve(filteredCSSText),\n  )\n}\n","import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n","import type { Options } from './types'\nimport { toArray } from './util'\nimport { fetchAsDataURL } from './dataurl'\nimport { shouldEmbed, embedResources } from './embed-resources'\n\ninterface Metadata {\n  url: string\n  cssText: string\n}\n\nconst cssFetchCache: { [href: string]: Metadata } = {}\n\nasync function fetchCSS(url: string) {\n  let cache = cssFetchCache[url]\n  if (cache != null) {\n    return cache\n  }\n\n  const res = await fetch(url)\n  const cssText = await res.text()\n  cache = { url, cssText }\n\n  cssFetchCache[url] = cache\n\n  return cache\n}\n\nasync function embedFonts(data: Metadata, options: Options): Promise<string> {\n  let cssText = data.cssText\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || []\n  const loadFonts = fontLocs.map(async (loc: string) => {\n    let url = loc.replace(regexUrl, '$1')\n    if (!url.startsWith('https://')) {\n      url = new URL(url, data.url).href\n    }\n\n    return fetchAsDataURL<[string, string]>(\n      url,\n      options.fetchRequestInit,\n      ({ result }) => {\n        cssText = cssText.replace(loc, `url(${result})`)\n        return [loc, result]\n      },\n    )\n  })\n\n  return Promise.all(loadFonts).then(() => cssText)\n}\n\nfunction parseCSS(source: string) {\n  if (source == null) {\n    return []\n  }\n\n  const result: string[] = []\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '')\n\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp(\n    '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})',\n    'gi',\n  )\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText)\n    if (matches === null) {\n      break\n    }\n    result.push(matches[0])\n  }\n  cssText = cssText.replace(keyframesRegex, '')\n\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi\n  // to match css & media queries together\n  const combinedCSSRegex =\n    '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n    '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText)\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText)\n      if (matches === null) {\n        break\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex\n    }\n    result.push(matches[0])\n  }\n\n  return result\n}\n\nasync function getCSSRules(\n  styleSheets: CSSStyleSheet[],\n  options: Options,\n): Promise<CSSStyleRule[]> {\n  const ret: CSSStyleRule[] = []\n  const deferreds: Promise<number | void>[] = []\n\n  // First loop inlines imports\n  styleSheets.forEach((sheet) => {\n    if ('cssRules' in sheet) {\n      try {\n        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {\n          if (item.type === CSSRule.IMPORT_RULE) {\n            let importIndex = index + 1\n            const url = (item as CSSImportRule).href\n            const deferred = fetchCSS(url)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  try {\n                    sheet.insertRule(\n                      rule,\n                      rule.startsWith('@import')\n                        ? (importIndex += 1)\n                        : sheet.cssRules.length,\n                    )\n                  } catch (error) {\n                    console.error('Error inserting rule from remote css', {\n                      rule,\n                      error,\n                    })\n                  }\n                }),\n              )\n              .catch((e) => {\n                console.error('Error loading remote css', e.toString())\n              })\n\n            deferreds.push(deferred)\n          }\n        })\n      } catch (e) {\n        const inline =\n          styleSheets.find((a) => a.href == null) || document.styleSheets[0]\n        if (sheet.href != null) {\n          deferreds.push(\n            fetchCSS(sheet.href)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  inline.insertRule(rule, sheet.cssRules.length)\n                }),\n              )\n              .catch((err: unknown) => {\n                console.error('Error loading remote stylesheet', err)\n              }),\n          )\n        }\n        console.error('Error inlining remote css file', e)\n      }\n    }\n  })\n\n  return Promise.all(deferreds).then(() => {\n    // Second loop parses rules\n    styleSheets.forEach((sheet) => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {\n            ret.push(item)\n          })\n        } catch (e) {\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e)\n        }\n      }\n    })\n\n    return ret\n  })\n}\n\nfunction getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {\n  return cssRules\n    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))\n}\n\nasync function parseWebFontRules<T extends HTMLElement>(\n  node: T,\n  options: Options,\n) {\n  if (node.ownerDocument == null) {\n    throw new Error('Provided element is not within a Document')\n  }\n\n  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)\n  const cssRules = await getCSSRules(styleSheets, options)\n\n  return getWebFontRules(cssRules)\n}\n\nexport async function getWebFontCSS<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<string> {\n  const rules = await parseWebFontRules(node, options)\n  const cssTexts = await Promise.all(\n    rules.map((rule) => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null\n      return embedResources(rule.cssText, baseUrl, options)\n    }),\n  )\n\n  return cssTexts.join('\\n')\n}\n\nexport async function embedWebFonts<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const cssText =\n    options.fontEmbedCSS != null\n      ? options.fontEmbedCSS\n      : options.skipFonts\n      ? null\n      : await getWebFontCSS(clonedNode, options)\n\n  if (cssText) {\n    const styleNode = document.createElement('style')\n    const sytleContent = document.createTextNode(cssText)\n\n    styleNode.appendChild(sytleContent)\n\n    if (clonedNode.firstChild) {\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild)\n    } else {\n      clonedNode.appendChild(styleNode)\n    }\n  }\n}\n","import { Options } from './types'\nimport { cloneNode } from './clone-node'\nimport { embedImages } from './embed-images'\nimport { applyStyle } from './apply-style'\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\nimport {\n  getImageSize,\n  getPixelRatio,\n  createImage,\n  canvasToBlob,\n  nodeToDataURL,\n  checkCanvasDimensions,\n} from './util'\n\nexport async function toSvg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const { width, height } = getImageSize(node, options)\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\n  await embedWebFonts(clonedNode, options)\n  await embedImages(clonedNode, options)\n  applyStyle(clonedNode, options)\n  const datauri = await nodeToDataURL(clonedNode, width, height)\n  return datauri\n}\n\nexport async function toCanvas<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<HTMLCanvasElement> {\n  const { width, height } = getImageSize(node, options)\n  const svg = await toSvg(node, options)\n  const img = await createImage(svg)\n\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')!\n  const ratio = options.pixelRatio || getPixelRatio()\n  const canvasWidth = options.canvasWidth || width\n  const canvasHeight = options.canvasHeight || height\n\n  canvas.width = canvasWidth * ratio\n  canvas.height = canvasHeight * ratio\n\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas)\n  }\n  canvas.style.width = `${canvasWidth}`\n  canvas.style.height = `${canvasHeight}`\n\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor\n    context.fillRect(0, 0, canvas.width, canvas.height)\n  }\n\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n  return canvas\n}\n\nexport async function toPixelData<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Uint8ClampedArray> {\n  const { width, height } = getImageSize(node, options)\n  const canvas = await toCanvas(node, options)\n  const ctx = canvas.getContext('2d')!\n  return ctx.getImageData(0, 0, width, height).data\n}\n\nexport async function toPng<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL()\n}\n\nexport async function toJpeg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\n}\n\nexport async function toBlob<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Blob | null> {\n  const canvas = await toCanvas(node, options)\n  const blob = await canvasToBlob(canvas)\n  return blob\n}\n\nexport async function getFontEmbedCSS<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  return getWebFontCSS(node, options)\n}\n","import { Options } from './types'\n\nexport function applyStyle<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): T {\n  const { style } = node\n\n  if (options.backgroundColor) {\n    style.backgroundColor = options.backgroundColor\n  }\n\n  if (options.width) {\n    style.width = `${options.width}px`\n  }\n\n  if (options.height) {\n    style.height = `${options.height}px`\n  }\n\n  const manual = options.style\n  if (manual != null) {\n    Object.keys(manual).forEach((key: any) => {\n      style[key] = manual[key] as string\n    })\n  }\n\n  return node\n}\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport './QrCode.scss';\r\nimport MaterialIcon from '@material/react-material-icon';\r\nimport { QRCode } from 'react-qrcode-logo';\r\nimport { toPng } from 'html-to-image';\r\nimport squaresPattern from '../../assets/images/qrcode/squares.jpg';\r\nimport fluidPattern from '../../assets/images/qrcode/fluid.jpg';\r\nimport dotsPattern from '../../assets/images/qrcode/dots.jpg';\r\nimport logo from '../../assets/images/qrcode/qr-code-logo.png';\r\n\r\nconst QrCodeGenerator = () => {\r\n  const [logoIsChecked, setLogoIsChecked] = useState(false);\r\n  const [selectedPattern, setSelectedPattern] = useState('squares');\r\n  const [eyeRadius, setEyeRadius] = useState(false);\r\n  const [selectedColor, setSelectedColor] = useState('#0f0f0f');\r\n  const [urlValue, setUrlValue] = useState('');\r\n  const [error, setError] = useState(false);\r\n\r\n  const elementRef = useRef(null);\r\n\r\n  const htmlToImageConvert = () => {\r\n    if (urlValue !== '') {\r\n      toPng(elementRef.current, { cacheBust: false }).then((dataUrl) => {\r\n        const link = document.createElement('a');\r\n        link.download = 'pemasys-qrcode.png';\r\n        link.href = dataUrl;\r\n        link.click();\r\n      });\r\n      setError(false);\r\n    } else {\r\n      setError(true);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (urlValue !== '') {\r\n      setError(false);\r\n    }\r\n  }, [urlValue]);\r\n\r\n  return (\r\n    <div className=\"qr-container\">\r\n      <div className=\"qr-body\">\r\n        <div className=\"qr-left\">\r\n          <div className=\"frame\" ref={elementRef} style={{ border: `2px solid ${selectedColor}` }}>\r\n            <QRCode\r\n              value={urlValue}\r\n              size={275}\r\n              qrStyle={selectedPattern}\r\n              eyeRadius={eyeRadius ? 10 : 0}\r\n              fgColor={selectedColor}\r\n              quietZone={5}\r\n              logoImage={logoIsChecked ? logo : ''}\r\n            />\r\n          </div>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Type Url..\"\r\n            onChange={(e) => setUrlValue(e.target.value)}\r\n          />\r\n          <div className=\"text-center\">\r\n            {error ? <span style={{ color: 'red' }}>Please enter url!</span> : <span> </span>}\r\n          </div>\r\n        </div>\r\n        <div className=\"qr-right\">\r\n          <div className=\"pattern\">\r\n            <span>Pattern</span>\r\n            <div className=\"pattern-item\">\r\n              <div onClick={() => setSelectedPattern('squares')}>\r\n                {selectedPattern === 'squares' && (\r\n                  <div className=\"checked-mark\">\r\n                    <MaterialIcon icon=\"check\" />\r\n                  </div>\r\n                )}\r\n                <img src={squaresPattern} alt=\"squares\" width=\"60\" height=\"60\" />\r\n              </div>\r\n              <div onClick={() => setSelectedPattern('fluid')}>\r\n                {selectedPattern === 'fluid' && (\r\n                  <div className=\"checked-mark\">\r\n                    <MaterialIcon icon=\"check\" />\r\n                  </div>\r\n                )}\r\n                <img src={fluidPattern} alt=\"squares\" width=\"60\" height=\"60\" />\r\n              </div>\r\n              <div onClick={() => setSelectedPattern('dots')}>\r\n                {selectedPattern === 'dots' && (\r\n                  <div className=\"checked-mark\">\r\n                    <MaterialIcon icon=\"check\" />\r\n                  </div>\r\n                )}\r\n                <img src={dotsPattern} alt=\"squares\" width=\"60\" height=\"60\" />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"pattern\">\r\n            <span>Color</span>\r\n            <div className=\"pattern-item\">\r\n              <div onClick={() => setSelectedColor('#0f0f0f')} className=\"color-1\">\r\n                {selectedColor === '#0f0f0f' && (\r\n                  <div className=\"checked-mark\">\r\n                    <MaterialIcon icon=\"check\" />\r\n                  </div>\r\n                )}\r\n              </div>\r\n              <div onClick={() => setSelectedColor('#0c69c7')} className=\"color-2\">\r\n                {selectedColor === '#0c69c7' && (\r\n                  <div className=\"checked-mark\">\r\n                    <MaterialIcon icon=\"check\" />\r\n                  </div>\r\n                )}\r\n              </div>\r\n              <div onClick={() => setSelectedColor('#5DCF8B')} className=\"color-3\">\r\n                {selectedColor === '#5DCF8B' && (\r\n                  <div className=\"checked-mark\">\r\n                    <MaterialIcon icon=\"check\" />\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"qr-radio\" onClick={() => setLogoIsChecked(!logoIsChecked)}>\r\n            <div className={`logo-check ${logoIsChecked && 'isChecked'}`}>\r\n              {logoIsChecked && <MaterialIcon icon=\"check\" />}\r\n            </div>\r\n            <span>Logo Pema</span>\r\n          </div>\r\n          <div className=\"qr-radio\" onClick={() => setEyeRadius(!eyeRadius)}>\r\n            <div className={`logo-check ${eyeRadius && 'isChecked'}`}>\r\n              {eyeRadius && <MaterialIcon icon=\"check\" />}\r\n            </div>\r\n            <span>Eye Radius</span>\r\n          </div>\r\n          <div className=\"btn-download\">\r\n            <button type=\"button\" onClick={htmlToImageConvert}>\r\n              Download Qr Code\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default QrCodeGenerator;\r\n"],"names":["uuid","counter","concat","Math","random","toString","slice","toArray","arrayLike","arr","i","l","length","push","px","node","styleProperty","val","ownerDocument","defaultView","window","getComputedStyle","getPropertyValue","parseFloat","replace","getImageSize","targetNode","options","arguments","undefined","width","leftBorder","rightBorder","clientWidth","getNodeWidth","height","topBorder","bottomBorder","clientHeight","getNodeHeight","canvasDimensionLimit","createImage","url","Promise","resolve","reject","img","Image","decode","onload","onerror","crossOrigin","decoding","src","async","nodeToDataURL","xmlns","svg","document","createElementNS","foreignObject","setAttribute","appendChild","then","XMLSerializer","serializeToString","encodeURIComponent","html","svgToDataURL","isInstanceOfElement","instance","nodePrototype","Object","getPrototypeOf","constructor","name","getPseudoElementStyle","className","pseudo","style","selector","cssText","content","formatCSSText","map","value","priority","getPropertyPriority","join","formatCSSProperties","createTextNode","clonePseudoElement","nativeNode","clonedNode","err","styleElement","createElement","WOFF","JPEG","mimes","woff","woff2","ttf","eot","png","jpg","jpeg","gif","tiff","webp","getMimeType","extension","match","exec","getExtension","toLowerCase","isDataUrl","search","makeDataUrl","mimeType","fetchAsDataURL","init","process","res","fetch","status","Error","blob","reader","FileReader","onloadend","result","error","readAsDataURL","cache","resourceToDataURL","resourceUrl","contentType","cacheKey","includeQueryParams","key","test","getCacheKey","dataURL","cacheBust","Date","getTime","fetchRequestInit","_ref","headers","get","split","getContentFromDataUrl","imagePlaceholder","msg","message","console","warn","cloneSingleNode","HTMLCanvasElement","canvas","toDataURL","cloneNode","cloneCanvasElement","HTMLVideoElement","video","currentSrc","ctx","getContext","drawImage","poster","cloneVideoElement","HTMLIFrameElement","iframe","_a","contentDocument","body","_b","cloneIFrameElement","isSlotElement","tagName","toUpperCase","decorate","Element","targetStyle","sourceStyle","transformOrigin","forEach","endsWith","reducedFont","floor","substring","getAttribute","setProperty","cloneCSSStyle","clonePseudoElements","HTMLTextAreaElement","innerHTML","HTMLInputElement","cloneInputValue","HTMLSelectElement","clonedSelect","selectedOption","Array","from","children","find","child","cloneSelectValue","isRoot","filter","assignedNodes","childNodes","shadowRoot","reduce","deferred","clonedChild","cloneChildren","clone","uses","querySelectorAll","processedDefs","id","exist","querySelector","definition","nodes","values","ns","position","overflow","display","defs","ensureSVGSymbols","URL_REGEX","URL_WITH_FORMAT_REGEX","FONT_SRC_REGEX","embed","resourceURL","baseURL","getContentFromUrl","resolvedURL","baseUrl","location","protocol","doc","implementation","createHTMLDocument","base","a","head","href","resolveUrl","escaped","RegExp","toRegex","shouldEmbed","embedResources","filteredCSSText","str","preferredFontFormat","format","filterPreferredFontFormat","urls","raw","quotation","parseURLs","css","embedProp","propName","propValue","cssString","embedImages","embedBackground","isImageElement","HTMLImageElement","SVGImageElement","baseVal","image","loading","srcset","embedImageNode","deferreds","all","embedChildren","cssFetchCache","fetchCSS","text","embedFonts","data","regexUrl","loadFonts","loc","startsWith","URL","parseCSS","source","keyframesRegex","matches","importRegex","unifiedRegex","lastIndex","parseWebFontRules","styleSheets","cssRules","ret","sheet","item","index","type","CSSRule","IMPORT_RULE","importIndex","metadata","rule","insertRule","catch","e","inline","getCSSRules","FONT_FACE_RULE","getWebFontRules","embedWebFonts","fontEmbedCSS","skipFonts","rules","parentStyleSheet","getWebFontCSS","styleNode","sytleContent","firstChild","insertBefore","toSvg","backgroundColor","manual","keys","applyStyle","toCanvas","context","ratio","pixelRatio","FINAL_PROCESS","env","devicePixelRatio","parseInt","Number","isNaN","getPixelRatio","canvasWidth","canvasHeight","skipAutoScale","checkCanvasDimensions","fillStyle","fillRect","QrCodeGenerator","logoIsChecked","setLogoIsChecked","useState","selectedPattern","setSelectedPattern","eyeRadius","setEyeRadius","selectedColor","setSelectedColor","urlValue","setUrlValue","setError","elementRef","useRef","useEffect","_jsx","_jsxs","ref","border","QRCode","size","qrStyle","fgColor","quietZone","logoImage","logo","placeholder","onChange","target","color","onClick","MaterialIcon","icon","squaresPattern","alt","fluidPattern","dotsPattern","htmlToImageConvert","toPng","current","dataUrl","link","download","click"],"sourceRoot":""}